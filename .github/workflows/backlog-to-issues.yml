name: Backlog → GitHub Issues

on:
  workflow_dispatch:
    inputs:
      project_id:
        description: "Optional: GitHub Project v2 node ID to add items to"
        required: false
        type: string
  push:
    paths:
      - "backlog.yml"

permissions:
    contents: read
    issues: write
    repository-projects: write

jobs:
  import-backlog:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install parser
        run: npm install js-yaml

      - name: Run importer
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const yaml = require('js-yaml');

            // Helpers
            const OWNER = context.repo.owner;
            const REPO  = context.repo.repo;
            const PROJECT_ID = core.getInput('project_id') || null;

            function mdWithMarker(item, body) {
              const marker = `<!-- BACKLOG-ID: ${item.id} -->`;
              // Keep marker at top; include normalized section for machine updates
              return [
                marker,
                body.trim(),
                '',
                '---',
                '',
                '_Managed by backlog importer. Do not remove the marker above._'
              ].join('\n');
            }

            async function ensureLabels(labels) {
              if (!labels || labels.length === 0) return;
              const existing = await github.rest.issues.listLabelsForRepo({ owner: OWNER, repo: REPO, per_page: 100 });
              const set = new Set(existing.data.map(l => l.name.toLowerCase()));
              for (const name of labels) {
                if (!set.has(name.toLowerCase())) {
                  try {
                    await github.rest.issues.createLabel({
                      owner: OWNER, repo: REPO, name, color: "6A5ACD" // slate-ish default
                    });
                    core.info(`Created label: ${name}`);
                  } catch (e) {
                    // Another concurrent run may have created; ignore 422
                    core.info(`Label ensure skipped: ${name} (${e.message})`);
                  }
                }
              }
            }

            async function findIssueByBacklogId(id) {
              const q = `repo:${OWNER}/${REPO} in:body "${'BACKLOG-ID: ' + id}" type:issue`;
              const res = await github.rest.search.issuesAndPullRequests({ q, per_page: 5 });
              const hit = res.data.items.find(i => i.body && i.body.includes(`<!-- BACKLOG-ID: ${id} -->`));
              return hit || null;
            }

            async function addToProjectV2(nodeId) {
              if (!PROJECT_ID) return;
              try {
                const result = await github.graphql(`
                  mutation($project: ID!, $content: ID!) {
                    addProjectV2ItemById(input: {projectId: $project, contentId: $content}) {
                      item { id }
                    }
                  }
                `, { project: PROJECT_ID, content: nodeId });
                core.info(`Added to project: ${JSON.stringify(result)}`);
              } catch (e) {
                core.warning(`Failed adding to project: ${e.message}`);
              }
            }

            // Load backlog.yml
            const doc = yaml.load(fs.readFileSync('backlog.yml', 'utf8'));
            const items = doc.items || [];
            const defaults = doc.defaults || {};
            const defaultLabels = defaults.labels || [];
            const defaultAssignees = defaults.assignees || [];
            const defaultMilestone = defaults.milestone || null;

            // Collect labels for ensure step
            const allLabels = new Set(defaultLabels);
            for (const it of items) {
              (it.labels || []).forEach(l => allLabels.add(l));
            }
            await ensureLabels([...allLabels]);

            // Pass 1: upsert issues, record map backlogId -> {number, node_id}
            const map = new Map();

            for (const it of items) {
              const labels = [...new Set([...(defaultLabels||[]), ...((it.labels)||[])])];
              const assignees = it.assignees && it.assignees.length ? it.assignees : defaultAssignees;
              const milestoneTitle = it.milestone ?? defaultMilestone;

              // Resolve milestone number, if provided
              let milestoneNumber = undefined;
              if (milestoneTitle) {
                const ms = await github.rest.issues.listMilestones({ owner: OWNER, repo: REPO, state: 'open', per_page: 100 });
                const match = ms.data.find(m => m.title === milestoneTitle);
                if (match) milestoneNumber = match.number;
              }

              const body = mdWithMarker(it, it.body || it.title);
              const current = await findIssueByBacklogId(it.id);

              if (!current) {
                // Create
                const created = await github.rest.issues.create({
                  owner: OWNER, repo: REPO,
                  title: it.title,
                  body,
                  labels,
                  assignees,
                  milestone: milestoneNumber
                });
                core.info(`Created #${created.data.number} for ${it.id}`);
                await addToProjectV2(created.data.node_id);
                map.set(it.id, { number: created.data.number, node_id: created.data.node_id, parent: it.parent });
              } else {
                // Update (title/body/labels/assignees/milestone)
                await github.rest.issues.update({
                  owner: OWNER, repo: REPO, issue_number: current.number,
                  title: it.title, body
                });
                if (labels && labels.length) {
                  await github.rest.issues.setLabels({
                    owner: OWNER, repo: REPO, issue_number: current.number, labels
                  });
                }
                if (assignees && assignees.length) {
                  await github.rest.issues.addAssignees({
                    owner: OWNER, repo: REPO, issue_number: current.number, assignees
                  });
                }
                if (milestoneTitle) {
                  await github.rest.issues.update({
                    owner: OWNER, repo: REPO, issue_number: current.number, milestone: milestoneNumber
                  });
                }
                core.info(`Updated #${current.number} for ${it.id}`);
                await addToProjectV2(current.node_id);
                map.set(it.id, { number: current.number, node_id: current.node_id, parent: it.parent });
              }
            }

            // Pass 2: parent → child task list links
            // For any item with "parent", add a "- [ ] #child" line to parent body if missing
            for (const [id, info] of map.entries()) {
              if (!info.parent) continue;
              const parentId = info.parent;
              const parentInfo = map.get(parentId);
              if (!parentInfo) {
                core.warning(`Parent not found in this run for ${id} -> ${parentId}`);
                continue;
              }
              const parentIssue = await github.rest.issues.get({ owner: OWNER, repo: REPO, issue_number: parentInfo.number });
              const line = `- [ ] #${info.number}`;
              if (!parentIssue.data.body.includes(line)) {
                const newBody = [
                  parentIssue.data.body.trim(),
                  '',
                  '**Backlog children**',
                  line,
                  ''
                ].join('\n');
                await github.rest.issues.update({
                  owner: OWNER, repo: REPO, issue_number: parentInfo.number, body: newBody
                });
                core.info(`Linked #${info.number} under parent #${parentInfo.number}`);
              }
            }
